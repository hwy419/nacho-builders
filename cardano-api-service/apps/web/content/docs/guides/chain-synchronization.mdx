---
title: Chain Synchronization
description: Follow the Cardano blockchain in real-time using WebSocket
category: guides
order: 4
---

Chain synchronization is the process of following the Cardano blockchain in real-time. When you connect to a Cardano node via WebSocket, you can receive new blocks the moment they're producedâ€”typically every 20 seconds on mainnet.

Think of it like a live feed of the blockchain. Instead of repeatedly polling "what's new?", the node pushes blocks to you as they arrive. This makes chain sync ideal for applications that need instant awareness of on-chain activity: wallets detecting payments, exchanges crediting deposits, or analytics tracking network activity.

The protocol is straightforward: you tell the node where you want to start (a specific block or the beginning of time), and it streams blocks forward from that point. If the chain reorganizes due to competing blocks, the node tells you to "roll back" and replay from the correct fork.

## What can you build with Chain Sync?

| Use Case | Description |
|----------|-------------|
| **Payment Monitoring** | Wallets and exchanges detect incoming transactions instantly. When ADA arrives at a watched address, notify users or credit accounts. |
| **Blockchain Explorers** | Index every block and transaction to make the chain searchable. Services like CardanoScan sync the entire history. |
| **DeFi Protocols** | DEXes track liquidity pool states, lending protocols monitor collateral positions, all in real-time. |
| **NFT Marketplaces** | Detect token mints, transfers, and metadata updates the moment they're confirmed on-chain. |
| **Analytics Dashboards** | Build real-time network statistics: TPS, active addresses, stake distribution changes. |
| **Alerting Systems** | Trigger webhooks or notifications when specific patterns occur (whale movements, smart contract calls). |

## Choose Your Network

| Network | WebSocket Endpoint |
|---------|-------------------|
| **Mainnet** | `wss://api.nacho.builders/v1/ogmios` |
| **Preprod** | `wss://api.nacho.builders/v1/preprod/ogmios` |

<Callout type="tip">
Use Preprod for development and testing. Your API key works on both networks.
</Callout>

Chain sync is essential for:

- Monitoring addresses for incoming transactions
- Building blockchain explorers
- Tracking token movements
- Real-time notifications

<Callout type="info">
  Chain synchronization requires a **WebSocket connection**. HTTP requests are not supported for this feature.
</Callout>

---

<Callout type="tip">
**Try it live!** Connect to the Cardano blockchain and watch the chain sync protocol in action. You'll see the full flow: querying the tip, finding an intersection, and streaming blocks.
</Callout>

<ChainSyncDemo />

## How It Works

```
1. Connect via WebSocket
2. Find an intersection point
3. Request blocks with nextBlock
4. Process each block (forward or rollback)
5. Repeat step 3
```

## Connect and Sync

<LanguageTabs examples={{
  javascript: `// Load API key from environment variable
const API_KEY = process.env.NACHO_API_KEY;

// Connect to the Ogmios WebSocket endpoint with API key as query param
const ws = new WebSocket(\`wss://api.nacho.builders/v1/ogmios?apikey=\${API_KEY}\`);

ws.onopen = () => {
  console.log('Connected to Ogmios');

  // STEP 1: Find an intersection point to start syncing from
  // Using 'origin' syncs from genesis (use specific slot/hash for resuming)
  ws.send(JSON.stringify({
    jsonrpc: '2.0',
    method: 'findIntersection',
    params: {
      points: ['origin']  // Can also be [{ slot: 12345, id: 'blockhash...' }]
    },
    id: 'find-intersection'
  }));
};

ws.onmessage = (event) => {
  const data = JSON.parse(event.data);

  // Handle the intersection response (tells us where we're starting)
  if (data.id === 'find-intersection') {
    console.log('Intersection found:', data.result.intersection);
    console.log('Tip:', data.result.tip);  // Current chain tip info

    // STEP 2: Start the block stream
    requestNextBlock();
  } else {
    // STEP 3: Process each block as it arrives
    handleBlock(data.result);
  }
};

function requestNextBlock() {
  // Request the next block in sequence (this drives the sync loop)
  ws.send(JSON.stringify({
    jsonrpc: '2.0',
    method: 'nextBlock',
    id: 'next'
  }));
}

function handleBlock(result) {
  if (result.direction === 'forward') {
    // New block received - process it
    const block = result.block;
    console.log(\`Block \${block.height}: \${block.transactions?.length || 0} txs\`);

    // Iterate through all transactions in this block
    block.transactions?.forEach(tx => {
      processTransaction(tx);
    });
  } else if (result.direction === 'backward') {
    // Chain rollback detected - undo state back to this point
    // Rollbacks happen when competing blocks are resolved
    console.log('Rollback to:', result.point);
  }

  // Continue the sync loop by requesting the next block
  requestNextBlock();
}

function processTransaction(tx) {
  console.log('  Tx:', tx.id);
  // === YOUR TRANSACTION PROCESSING LOGIC HERE ===
  // Check tx.outputs for payments to your addresses
  // Check tx.inputs to detect spent UTxOs
}

ws.onerror = (error) => console.error('WebSocket error:', error);
ws.onclose = () => console.log('Connection closed');`,
  typescript: `// Type definitions for chain sync responses
interface BlockResult {
  direction: 'forward' | 'backward';  // forward = new block, backward = rollback
  block?: Block;    // Present when direction is 'forward'
  point?: Point;    // Present when direction is 'backward' (rollback target)
}

interface Block {
  height: number;                    // Block number (sequential)
  id: string;                        // Block hash
  slot: number;                      // Slot number (time-based)
  transactions?: Transaction[];      // All transactions in this block
}

interface Transaction {
  id: string;                        // Transaction hash
  inputs: { transaction: { id: string }; index: number }[];   // Spent UTxOs
  outputs: { address: string; value: object }[];              // Created UTxOs
}

interface Point {
  slot: number;    // Slot number to rollback to
  id: string;      // Block hash at that slot
}

/**
 * Reusable chain sync client with callbacks for blocks and rollbacks.
 * Encapsulates the WebSocket connection and message handling.
 */
class ChainSync {
  private ws: WebSocket;
  private onBlock: (block: Block) => void;
  private onRollback: (point: Point) => void;

  constructor(
    apiKey: string,
    onBlock: (block: Block) => void,      // Called for each new block
    onRollback: (point: Point) => void    // Called when chain rolls back
  ) {
    this.onBlock = onBlock;
    this.onRollback = onRollback;
    // Connect with API key as query parameter
    this.ws = new WebSocket(\`wss://api.nacho.builders/v1/ogmios?apikey=\${apiKey}\`);
    this.setupHandlers();
  }

  private setupHandlers() {
    // On connect, immediately find intersection to start syncing
    this.ws.onopen = () => this.findIntersection();
    // Route all messages through our handler
    this.ws.onmessage = (event) => this.handleMessage(JSON.parse(event.data));
    this.ws.onerror = (error) => console.error('WebSocket error:', error);
  }

  private findIntersection() {
    // Find where to start syncing (origin = from genesis, returns tip info)
    this.ws.send(JSON.stringify({
      jsonrpc: '2.0',
      method: 'findIntersection',
      params: { points: ['origin'] },
      id: 'find-intersection'
    }));
  }

  private handleMessage(data: any) {
    if (data.id === 'find-intersection') {
      // Intersection found, start the block stream
      this.requestNextBlock();
    } else {
      // Process block or rollback based on direction
      const result = data.result as BlockResult;
      if (result.direction === 'forward' && result.block) {
        this.onBlock(result.block);           // New block - process it
      } else if (result.direction === 'backward' && result.point) {
        this.onRollback(result.point);        // Rollback - undo to this point
      }
      // Continue the sync loop
      this.requestNextBlock();
    }
  }

  private requestNextBlock() {
    // Drives the sync - each call returns the next block in sequence
    this.ws.send(JSON.stringify({
      jsonrpc: '2.0',
      method: 'nextBlock',
      id: 'next'
    }));
  }

  close() {
    this.ws.close();  // Clean shutdown
  }
}

// Usage example: create sync client with callback handlers
const sync = new ChainSync(
  process.env.NACHO_API_KEY!,
  (block) => console.log(\`Block \${block.height}\`),           // Handle new blocks
  (point) => console.log(\`Rollback to slot \${point.slot}\`)   // Handle rollbacks
);`,
  python: `import asyncio
import websockets
import json
import os

class ChainSync:
    """Async chain sync client using WebSocket connection."""

    def __init__(self, api_key: str):
        self.api_key = api_key
        # WebSocket endpoint with API key as query parameter
        self.uri = f"wss://api.nacho.builders/v1/ogmios?apikey={api_key}"

    async def sync(self, on_block, on_rollback):
        """
        Start syncing blocks from the chain.

        Args:
            on_block: Async callback called for each new block
            on_rollback: Async callback called when chain rolls back
        """
        async with websockets.connect(self.uri) as ws:
            # STEP 1: Find intersection point to start syncing
            # Using "origin" syncs from genesis but returns current tip
            await ws.send(json.dumps({
                "jsonrpc": "2.0",
                "method": "findIntersection",
                "params": {"points": ["origin"]},
                "id": "find-intersection"
            }))

            # Wait for intersection response (tells us where we're starting)
            response = await ws.recv()
            data = json.loads(response)
            print(f"Intersection: {data['result']['intersection']}")

            # STEP 2: Main sync loop - request and process blocks
            while True:
                # Request the next block in sequence
                await ws.send(json.dumps({
                    "jsonrpc": "2.0",
                    "method": "nextBlock",
                    "id": "next"
                }))

                # Wait for block response
                response = await ws.recv()
                data = json.loads(response)
                result = data["result"]

                # STEP 3: Handle block based on direction
                if result["direction"] == "forward":
                    # New block - pass to handler
                    await on_block(result["block"])
                elif result["direction"] == "backward":
                    # Chain rollback - undo state to this point
                    await on_rollback(result["point"])

# Example block handler - called for each new block
async def handle_block(block):
    tx_count = len(block.get('transactions', []))
    print(f"Block {block['height']}: {tx_count} txs")
    # === ADD YOUR LOGIC HERE ===
    # Process transactions, check for payments, etc.

# Example rollback handler - called when chain reorganizes
async def handle_rollback(point):
    print(f"Rollback to slot {point['slot']}")
    # === UNDO YOUR STATE HERE ===
    # Remove any data from blocks after this point

async def main():
    api_key = os.environ["NACHO_API_KEY"]
    sync = ChainSync(api_key)
    # Start syncing with our callback handlers
    await sync.sync(handle_block, handle_rollback)

# Run the async main function
asyncio.run(main())`,
  go: `package main

import (
    "encoding/json"
    "log"
    "os"

    "github.com/gorilla/websocket"
)

type BlockResult struct {
    Direction string \`json:"direction"\`
    Block     *Block \`json:"block,omitempty"\`
    Point     *Point \`json:"point,omitempty"\`
}

type Block struct {
    Height       int           \`json:"height"\`
    ID           string        \`json:"id"\`
    Slot         int           \`json:"slot"\`
    Transactions []Transaction \`json:"transactions"\`
}

func main() {
    apiKey := os.Getenv("NACHO_API_KEY")
    url := "wss://api.nacho.builders/v1/ogmios?apikey=" + apiKey

    conn, _, err := websocket.DefaultDialer.Dial(url, nil)
    if err != nil {
        log.Fatal("dial:", err)
    }
    defer conn.Close()

    // Find intersection
    conn.WriteJSON(map[string]interface{}{
        "jsonrpc": "2.0",
        "method":  "findIntersection",
        "params":  map[string]interface{}{"points": []string{"origin"}},
        "id":      "find-intersection",
    })

    for {
        _, message, err := conn.ReadMessage()
        if err != nil {
            log.Println("read:", err)
            return
        }

        var response map[string]interface{}
        json.Unmarshal(message, &response)

        // Request next block
        conn.WriteJSON(map[string]interface{}{
            "jsonrpc": "2.0",
            "method":  "nextBlock",
            "id":      "next",
        })
    }
}`,
  rust: `use tokio_tungstenite::{connect_async, tungstenite::Message};
use futures_util::{SinkExt, StreamExt};
use serde_json::json;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let api_key = std::env::var("NACHO_API_KEY")?;
    let url = format!("wss://api.nacho.builders/v1/ogmios?apikey={}", api_key);

    let (ws_stream, _) = connect_async(&url).await?;
    let (mut write, mut read) = ws_stream.split();

    // Find intersection
    write.send(Message::Text(json!({
        "jsonrpc": "2.0",
        "method": "findIntersection",
        "params": { "points": ["origin"] },
        "id": "find-intersection"
    }).to_string())).await?;

    while let Some(msg) = read.next().await {
        if let Ok(Message::Text(text)) = msg {
            let data: serde_json::Value = serde_json::from_str(&text)?;

            if let Some(result) = data.get("result") {
                if result.get("direction").and_then(|d| d.as_str()) == Some("forward") {
                    if let Some(block) = result.get("block") {
                        println!("Block {}", block["height"]);
                    }
                }
            }

            // Request next block
            write.send(Message::Text(json!({
                "jsonrpc": "2.0",
                "method": "nextBlock",
                "id": "next"
            }).to_string())).await?;
        }
    }

    Ok(())
}`,
  curl: `# Chain sync requires WebSocket. Use wscat for testing:
wscat -c "wss://api.nacho.builders/v1/ogmios?apikey=$NACHO_API_KEY"

# Then send:
# {"jsonrpc":"2.0","method":"findIntersection","params":{"points":["origin"]},"id":"1"}
# {"jsonrpc":"2.0","method":"nextBlock","id":"2"}`
}} />

## Finding an Intersection Point

The `findIntersection` method finds a common point between your view and the node's chain:

```javascript
// Start from genesis (sync entire chain)
{ "points": ["origin"] }

// Start from a specific block
{
  "points": [
    { "slot": 12345678, "id": "abc123..." }
  ]
}

// Try multiple points (node picks best match)
{
  "points": [
    { "slot": 12345678, "id": "abc123..." },
    { "slot": 12345600, "id": "def456..." },
    "origin"
  ]
}
```

<Callout type="tip">
  For real-time monitoring, first query `queryNetwork/tip` to get the current tip, then use that as your intersection point.
</Callout>

## Handling Rollbacks

Cardano uses a longest-chain rule. Occasionally, blocks are rolled back:

```javascript
function handleBlock(result) {
  if (result.direction === 'forward') {
    // New block - add to your state
    applyBlock(result.block);
  } else if (result.direction === 'backward') {
    // Rollback - undo blocks back to this point
    rollbackTo(result.point);
  }
}

function rollbackTo(point) {
  // Remove any blocks after this point
  // Re-process transactions that were in rolled-back blocks
  console.log(`Rolling back to slot ${point.slot}`);
}
```

Rollbacks are typically 1-2 blocks but can be up to ~2160 blocks (security parameter k).

## Monitoring Specific Addresses

Filter chain data for addresses you care about:

```javascript
const watchedAddresses = new Set([
  'addr1...',
  'addr1...'
]);

function processTransaction(tx) {
  // Check outputs
  tx.outputs?.forEach((output, index) => {
    if (watchedAddresses.has(output.address)) {
      console.log(`Incoming transaction to ${output.address}`);
      console.log(`  TxHash: ${tx.id}`);
      console.log(`  Amount: ${output.value.ada.lovelace} lovelace`);

      // Emit notification, update database, etc.
      notifyIncoming(tx.id, output);
    }
  });

  // Check inputs (for outgoing)
  tx.inputs?.forEach(input => {
    // You'd need to look up the input's address
    // from your local UTxO tracking
  });
}
```

## Pipelining Requests

For faster sync, pipeline multiple `nextBlock` requests:

```javascript
// Number of concurrent requests to keep in flight
// Higher = faster sync, but uses more memory
const PIPELINE_DEPTH = 100;
let pending = 0;  // Track how many requests are awaiting responses

function requestBlocks(count) {
  // Send multiple nextBlock requests without waiting for responses
  for (let i = 0; i < count; i++) {
    ws.send(JSON.stringify({
      jsonrpc: '2.0',
      method: 'nextBlock',
      id: `block-${Date.now()}-${i}`  // Unique ID for each request
    }));
    pending++;
  }
}

ws.onmessage = (event) => {
  const data = JSON.parse(event.data);

  // Check if this is a block response (not intersection)
  if (data.result?.block || data.result?.direction) {
    handleBlock(data.result);
    pending--;  // One response received

    // Refill the pipeline when it drops below half capacity
    // This keeps blocks streaming in continuously
    if (pending < PIPELINE_DEPTH / 2) {
      requestBlocks(PIPELINE_DEPTH - pending);
    }
  }
};

// Initial setup
ws.onopen = () => {
  findIntersection();
  // After intersection found, fill the pipeline to start fast sync
};
```

## Reconnection Strategy

WebSocket connections can drop. Implement reconnection:

```javascript
/**
 * Chain sync client with automatic reconnection.
 * Tracks last processed block to resume from the correct point.
 */
class ResilientChainSync {
  constructor(apiKey, onBlock) {
    this.apiKey = apiKey;
    this.onBlock = onBlock;
    // Store the last processed block point for resuming after reconnect
    this.lastPoint = null;
    this.connect();
  }

  connect() {
    this.ws = new WebSocket(
      `wss://api.nacho.builders/v1/ogmios?apikey=${this.apiKey}`
    );

    this.ws.onopen = () => {
      // On reconnect, try to resume from last known point
      // Falls back to 'origin' if no previous state
      const points = this.lastPoint
        ? [this.lastPoint, 'origin']  // Try last point first, then origin
        : ['origin'];                  // First connection - start from genesis

      this.ws.send(JSON.stringify({
        jsonrpc: '2.0',
        method: 'findIntersection',
        params: { points }
      }));
    };

    this.ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      if (data.result?.block) {
        // Save this block as our resume point for reconnection
        this.lastPoint = {
          slot: data.result.block.slot,
          id: data.result.block.id
        };
        // Pass block to handler
        this.onBlock(data.result.block);
      }
      // Continue the sync loop
      this.requestNext();
    };

    this.ws.onclose = () => {
      // Connection lost - schedule reconnection
      // Production apps should use exponential backoff
      console.log('Connection closed, reconnecting in 5s...');
      setTimeout(() => this.connect(), 5000);
    };

    this.ws.onerror = (error) => {
      console.error('WebSocket error:', error);
      // Error will trigger onclose, which handles reconnection
    };
  }

  requestNext() {
    // Only send if connection is open (prevents errors during reconnect)
    if (this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify({
        jsonrpc: '2.0',
        method: 'nextBlock'
      }));
    }
  }
}
```

## Performance Considerations

| Scenario | Recommendation |
|----------|----------------|
| Full history sync | Use pipelining, store checkpoints |
| Real-time monitoring | Start from tip, single requests |
| Multiple addresses | Single connection, filter in code |
| High availability | Multiple connections with failover |

<Callout type="warning">
  Chain sync maintains an open WebSocket. FREE tier allows 5 concurrent connections; PAID allows 50.
</Callout>

## Billing

Chain sync messages are billed per message in both directions:

| Message Type | Direction | Credits (PAID) |
|--------------|-----------|----------------|
| `nextBlock` request | Sent | 1 |
| Block response | Received | 1 |
| `findIntersection` | Sent | 1 |
| Intersection result | Received | 1 |

**Example costs:**
- Following the tip (real-time): ~6 messages/minute = ~360 credits/hour
- Syncing 1,000 historical blocks: ~2,000 credits (1,000 requests + 1,000 responses)

<Callout type="tip">
  FREE tier users are not charged credits but are subject to daily limits (100,000 messages/day) and rate limits (100 msg/sec).
</Callout>
